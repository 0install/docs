<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<h2>Feed file format specification</h2>

<p>
This document is a formal description of the XML feed file format. An interface describes a program,
library or other component. A feed provides a list of known implementations of the interface (versions of the program)
and details about how to get them, how to check that they are authentic, how to run them and what other components
they depend on.
</p>

<p>
This class diagram shows how the different concepts are related. Each feed file contributes information to this model:
</p>

<p class='uml'>
 <img src='UML/zero-install-feed-classes.png' width='665' height='358' alt='Class diagram for feed files'/>
</p>

<p>
Each <k>Feed</k> lists a number of <k>Implementations</k>. An <k>Identity</k> is a way to
recognise an Implementation (e.g. a cryptographic digest). A <k>Retrieval method</k>
is a way to get an Implementation (e.g. by downloading from an FTP site). A
<k>Binding</k> says how to let the program locate the Implementations when run. A
<k>Dependency</k> indicates that one component depends on another (e.g. Gimp requires
the GTK library). A <k>Constraint</k> limits the choice of a dependency (e.g. Gimp
requires a version of GTK >= 2.6).
</p>

<p>
Note on terminology: originally the word 'interface' was used to mean both 'interface' and 'feed', so don't
be confused if you see it used this way.
</p>

<p>
A RELAX NG schema can be found in <a href='https://zero-install.svn.sourceforge.net/svnroot/zero-install/trunk/htdocs/schema/'>/svnroot/zero-install/trunk/htdocs/schema</a>.
</p>

<p>
Changes to this document (and to the rest of the web-site) are tracked using subversion. To view
the change log:
</p>

<pre>
$ svn log https://zero-install.svn.sourceforge.net/svnroot/zero-install/trunk/htdocs/interface-spec.xml
</pre>

<h2>Contents</h2>
<toc level='h2'/>

<h2>Introduction</h2>

<p>
Feed files are introduced in the <a href='injector-packagers.html'>packager's guide</a>.
They have the following syntax (? follows optional items, * means zero-or-more, order of elements
is not important, and extension elements can appear anywhere as long as they use a different
namespace):
</p>

<pre>
&lt;?xml version='1.0'?&gt;
&lt;interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface'
	   min-injector-version='...' ?
	   uri='...' ? &gt;
  &lt;name&gt;...&lt;/name&gt;
  &lt;summary&gt;...&lt;/summary&gt;
  &lt;description&gt;...&lt;/description&gt; ?
  &lt;homepage&gt;...&lt;/homepage&gt; ?
  &lt;category type='...' ? &gt;...&lt;/category&gt; *
  &lt;needs-terminal/&gt; ?

  &lt;icon type='...' href='...'/&gt; *
  &lt;feed src='...' langs='...' ? arch='...' ?/&gt; *
	
  &lt;feed-for interface='...'/&gt; *

  [group] *
  [implementation] *

&lt;/interface&gt;
</pre>

<dl>

<dt>min-injector-version</dt>
<dd>This attribute gives the oldest version of the injector that can read this file. Older versions will
tell the user to upgrade if they are asked to read the file. Versions prior to 0.20 do not perform this check, however.
If the attribute is not present, the file can be read by all versions.
</dd>

<dt>uri</dt>
<dd>This attribute is only needed for remote feeds (fetched via HTTP). The value must exactly match the expected
URL, to prevent an attacker replacing one correctly-signed feed with another (e.g., returning a feed for the
<b>shred</b> program when the user asked for the <b>backup</b> program).
</dd>

<dt>&lt;name&gt;</dt> <dd>a short name to identify the interface (e.g. "Foo")</dd>
<dt>&lt;summary&gt;</dt> <dd>a short one-line description; the first word should
not be upper-case unless it is a proper noun (e.g. "cures all ills")</dd>
<dt>&lt;description&gt;</dt> <dd>a full description, which can be several paragraphs long (optional since 0.32, but recommended)</dd>
<dt>&lt;homepage&gt;</dt> <dd>the URL of a web-page describing this interface in more detail</dd>
<dt>&lt;category&gt;</dt> <dd>a classification for the interface. If no type is given, then the category is one of the
'Main' categories defined by the <a href='http://standards.freedesktop.org/menu-spec/latest/apa.html'>freedesktop.org menu specification</a>. Otherwise, it is a URI giving the namespace for the category.</dd>
<dt>&lt;needs-terminal&gt;</dt> <dd>if present, this element indicates that the program requires a terminal in order to run. Graphical launchers should therefore run this program in a suitable terminal emulator.</dd>
<dt>&lt;icon&gt;</dt> <dd>an icon to use for the program; this is used by programs such as
<a href="http://rox.sourceforge.net/desktop/AddApp">AddApp</a>.</dd>
<dt>&lt;feed&gt;</dt> <dd>the linked feed contains more implementations of this feed's interface. The "langs" and "arch" attributes, if present, indicate that all implementations will fall within
these limits (e.g. arch='*-src' means that there is no point fetching this feed
unless you are looking for source code). See the &lt;implementation&gt; element
for a description of the values of these attributes.</dd>
<dt>&lt;feed-for&gt;</dt> <dd>the implementations in this feed are implementations of the given interface. This is used when adding a third-party feed.</dd>

</dl>

<h2>Groups</h2>

<p>
A group has this syntax:
</p>

<pre>
  &lt;group
  	version='...' ?
       	released='...' ?
	main='...' ?
	self-test='...' ?
	doc-dir='...' ?
	license='...' ?
        stability='...' ?
	langs='...' ?
        arch='...' ? &gt;
    [requires] *
    [group] *
    [binding] *
    [implementation] *
    [package-implementation] *
  &lt;/group&gt;
</pre>

<p>
All attributes of the group are inherited by any child groups and implementations as defaults, but
can be overridden there. All dependencies ("requires") and bindings are inherited (sub-groups may add more
dependencies and bindings to the list, but cannot remove anything).
</p>

<h2>Implementations</h2>

<p>
An implementation has this syntax (an unspecified argument is inherited from
the closest ancestor &lt;group&gt; which defines it):
</p>

<pre>
  &lt;implementation
	id='...'
  	version='...' ?
  	version-modifier='...' ?
	main='...' ?
	self-test='...' ?
	doc-dir='...' ?
  	released='...' ?
	stability='...' ?
	langs='...' ?
	arch='...' ? &gt;
    &lt;manifest-digest [digest] * /> *
    [retrieval-method] *
    [binding] *
    [requires] *
  &lt;/implementation&gt;
</pre>

<p class='uml'>
  <img src='UML/zero-install-id.png' width='405' height='205' alt='Identity classes'/>
</p>

<dl>
 <dt>id</dt>
 <dd>The digest of the implementation's manifest, in the form <b>alg=value</b>.
 See the <a href='manifest-spec.html'>manifest specification</a> for details
 about manifests. If the feed file is a local file (the interface 'uri'
 starts with <b>/</b>) then the <b>id</b> <i>may</i> instead contain the
 pathname of a local directory (either an absolute path or a path relative
 to the directory containing the feed file).</dd>

 <dt>version</dt>
 <dd>The version number. See the version numbers section below for more details.</dd>

 <dt>version-modifier</dt>
 <dd>A string to be appended to the version. The purpose of this is to allow complex version numbers (such as
 "1.0-rc2") without breaking older versions of the injector (before 0.24), which only support dot-separated
 lists of integers.</dd>

 <dt>main</dt>
 <dd>The relative path of an executable inside the implementation that should be executed by default
 when the interface is run. If an implementation has no <b>main</b> setting, then it cannot be executed
 without specifying one manually (with <b>0launch --main=MAIN</b>). This typically means that the interface
 is for a library.</dd>

 <dt>self-test</dt>
 <dd>The relative path of an executable inside the implementation that can be executed to test the program.
 The program must be non-interactive (e.g. it can't open any windows or prompt for input).
 It should return with an exit status of zero if the tests pass. Any other status indicates failure.
 </dd>

 <dt>doc-dir</dt>
 <dd>The relative path of a directory inside the implementation that contains the package's documentation.
 This is the directory that would end up inside <b>/usr/share/doc</b> on a traditional Linux system.</dd>

 <dt>released</dt>
 <dd>The date this implementation was made available, in the format YYYY-MM-DD. For development versions checked
 out from version control this attribute should not be present.</dd>

 <dt>stability</dt>
 <dd>The default stability rating for this implementation. If not present, <b>testing</b> is used.
 See the stability section below for more details.</dd>

 <dt>langs</dt>
 <dd>The natural language(s) which this package supports, as a space-separated
 list of languages codes (in the same format as used by the $LANG environment
 variable). For example, the value "en_GB fr" would be used for a package
 supporting British English and French. This attribute is currently ignored by 0launch.</dd>

 <dt>arch</dt>
 <dd>For platform-specific binaries, the platform for which this implementation was compiled, in the form <b>os-cpu</b>.
 The injector knows that certain platforms are backwards-compatible with others, so binaries with <b>arch="Linux-i486"</b>
 will still be available on <i>Linux-i686</i> machines, for example. Either the <i>os</i> or <i>cpu</i> part may be <b>*</b>,
 which will make it available on any OS or CPU. If missing, the default is <b>*-*</b>.</dd>

 <dt>license</dt>
 <dd>License terms (typically a Trove category, as used on <a href='http://freshmeat.net/browse/13/'>freshmeat.net</a>).</dd>
</dl>

<p>
For non-local implementations (those where the <b>id</b> doesn't start with
<b>/</b>), the element contains a set of <i>retrieval methods</i>, each of
which gives a different way of getting the implementation (i.e., of getting a
directory structure whose digest matches the one in the <b>id</b>).
</p>

<p>
The <b>manifest-digest</b> element can be used to give the digest using other
algorithms (in addition to the one used in the <b>id</b> attribute). It is
currently ignored. This is to allow a smooth upgrade to newer digest algorithms
without breaking old clients. Each non-namespaced attribute gives a digest, with
the attribute name being the algorithm. For example:
</p>

<pre>
&lt;manifest-digest sha256="4f078f9080bd9b3b87e8360f014268886ec653ed077bb3cb6725185c0a07473a"/>
</pre>

<p>
Unrecognised elements inside an implementation are ignored. Currently, the
injector always chooses the first of the methods it understands, but in future
it may use other strategies (such as choosing the closest mirror, or letting
the user select one manually). It may also use other methods which aren't listed,
such as searching for the implementation on a peer-to-peer network.
</p>

<h2>Package implementations</h2>

<p>
This element names a distribution-provided package which, if present, is a valid
implementation of this interface. The syntax is:
</p>

<pre>
  &lt;package-implementation
    package='...'
    main='...' ? &gt;
</pre>

<p>
If the named package is available then it will be considered as a possible implementation
of the interface. If <b>main</b> is given then it must be an absolute path.
</p>

<p>
Note that, unlike a normal implementation, a distribution package does not resolve to a directory.
Any bindings inside &lt;requires&gt; elements for the interface will be ignored; it is assumed that
the requiring component knows how to use the packaged version without further help. Therefore, adding
distribution packages to your interface considerably weakens the guarantees you are making about what
the requestor may get.
</p>

<p>
Package implementations still inherit attributes and dependencies from their parent group. The
<b>doc-dir</b> and <b>license</b> attributes may be given, but <b>version</b> and <b>released</b>
are read from the native packaging system.
</p>

<p>
Support for distribution packages was added in version 0.28 of the injector. Earlier versions ignore
this element. Future versions may provide a way to specify which distributions the element applies
to.
</p>

<h2>Retrieval methods</h2>

<p>
A retrieval method is a way of getting an implementation.
</p>

<p class='uml'>
  <img src='UML/zero-install-retr.png' width='205' height='385' alt='Retrieval method classes'/>
</p>

<p>
The simplest retrieval method is the &lt;archive&gt; element:
</p>

<pre id='retrievalmethods'>
    &lt;archive
      href='...'
      size='...'
      extract='...' ?
      type='...' ?
      start-offset='...' ? /&gt;
</pre>

<p>
This states that an archive may be downloaded from the address given in the <b>href</b> attribute. The archive must
have the given <b>size</b> or it will be rejected. When unpacked (either the subdirectory named in the <b>extract</b>
attribute, or the whole archive if it is not present), the resulting tree will generate a manifest with the secure hash
value given as the implementation's <b>id</b>.
</p>

<p>
The type of the archive is given as a MIME type in the <b>type</b> attribute
(since <b>0launch</b> version 0.21). If missing, the type is guessed from the extension on the
<b>href</b> attribute (all versions). Known types and extensions (case insensitive) are:
</p>

<ul>
 <li>application/x-rpm (.rpm)</li>
 <li>application/x-deb (.deb)</li>
 <li>application/x-tar (.tar)</li>
 <li>application/x-bzip-compressed-tar (.tar.bz2)</li>
 <li>application/x-lzma-compressed-tar (.tar.lzma)</li>
 <li>application/x-compressed-tar (.tar.gz or .tgz)</li>
 <li>application/zip (.zip)</li>
 <li>application/vnd.ms-cab-compressed (.cab)</li>
</ul>

<p>
The <b>start-offset</b> attribute (since version 0.21) gives the number of
bytes at the beginning of the file which should be ignored. This is useful for
some self-extracting archives which are made up of a shell script followed by a
normal archive in a single file. If missing, it defaults to 0. The value in the
<b>size</b> attribute does not include the skipped bytes.
</p>

<p>
An implementation can also be created by following a &lt;recipe&gt;:
</p>

<pre>
  &lt;recipe&gt;
    &lt;archive ...&gt; +
  &lt;/recipe&gt;
</pre>

<p>
In this case, each child element of the recipe represents a step. To get an implementation by following a recipe,
a new empty directory is created and then all of the steps are performed in sequence. The resulting directory
must have the digest given in the implementation's <b>id</b>. A recipe containing only a single archive is equivalent
to just specifying the archive on its own (except that recipes aren't supported prior to version 0.20 of the injector).
If a recipe contains an unrecognised element then the whole recipe must be ignored.
</p>

<p>
The only type of step supported is an &lt;archive&gt;, which causes the named
archive to be fetched and unpacked over the top of whatever is currently in the temporary directory.
</p>

<p>
Note: A recipe is generally only useful for patching existing archives without having to host the complete result
yourself. Normally, if your program requires files from several different packages then it is better to use the
&lt;requires&gt; element instead. This allows libraries to be shared between different programs, and lets the user
choose the versions and upgrade them individually.
</p>

<h2>Dependencies</h2>

<p>
A &lt;requires&gt; element means that every implementation within the same group (including nested
sub-groups) requires an implementation of the specified interface when run. The injector will choose a
suitable implementation, downloading one if required.
</p>

<pre>
  &lt;requires
	interface='...' &gt;
    [ constraints ] *
    [ bindings ] *
  &lt;/requires&gt;
</pre>

<p>
The constraint elements (if any) limit the set of acceptable versions. The bindings specify how
the injector should make its choice known (typically, by setting environment variables).
</p>

<h2>Constraints</h2>

<p>
Constraints appear inside &lt;requires&gt; elements. They restrict the set of versions from which the
injector may choose an implementation.
</p>

<pre>
    &lt;version
	not-before='...' ?
	before='...' ? &gt;
</pre>

<dl>
<dt>not-before</dt>
<dd>This is the lowest-numbered version that can be chosen.</dd>

<dt>before</dt>
<dd>This version and all later versions are unsuitable.</dd>
</dl>

<p>For example, <b>&lt;version not-before='2.4' before='2.6'&gt;</b> allows any of these
versions: 2.4, 2.4.0, and 2.4.8. It will not select 2.3.9 or 2.6.
</p>

<h2>Bindings</h2>

<p>
Bindings specify how the chosen implementation is made known to the running program. Bindings
can appear in a &lt;requires&gt; element, in which case they tell a component how to find its
dependency, or in an &lt;implementation&gt; (or group), where they tell a component how to find
itself.
</p>

<p class='uml'>
  <img src='UML/zero-install-binding.png' width='275' height='225' alt='Binding classes'/>
</p>

<p>
<strong>Note:</strong> Bindings outside of &lt;requires&gt; elements require 0launch >= 0.31.
However, the same effect can be achieved with earlier versions of 0launch by
adding an explicit &lt;requires&gt; from a component to itself and putting the
binding in that.
</p>

<h3>Environment bindings</h3>

<pre>
    &lt;environment
	  name='...'
	  insert='...'
	  mode='prepend|append|replace' ?
	  default='...' ? /&gt; *
</pre>

<p>
The location of the chosen implementation is passed to the program by setting environment variables,
as specified by the &lt;environment&gt; elements (typically, there will be exactly one of these in each
&lt;requires&gt; element). Each environment element gives the name of the variable and the relative path
of the item within the implementation to insert into the variable's value.
</p>

<p>
If <b>mode</b> is <b>prepend</b> (or not set), then the absolute path of the
item is prepended to the current value of the variable, separated by a colon
character. If the environment variable is not currently set then the path is
prepended to the value of the default attribute. If no default value is given
either then the default for that environment variable is used, or the
environment variable's value is set to the absolute path directly if there is
no default.
</p>

<p>
If <b>mode</b> is <b>append</b> then the same thing happens, except that the new
value is added at the end instead of the beginning. If the mode is <b>replace</b> then
the old value is overwritten, and the <b>default</b> attribute is ignored.
</p>

<p>
For example, &lt;environment name='PATH' insert='bin'/&gt; would perform something similar to the
bash shell statement <b>export PATH=/path/to/impl/bin:$PATH</b>.
</p>

<p>
The following environment variables have known defaults and therefore the <b>default</b> attribute is not
needed with them:
</p>

<dl>
<dt>PATH</dt><dd>/bin:/usr/bin</dd>
<dt>XDG_CONFIG_DIRS</dt><dd>/etc/xdg</dd>
<dt>XDG_DATA_DIRS</dt><dd>/usr/local/share:/usr/share</dd>
</dl>

<p>
The <b>mode</b> argument is ignored by versions of the injector prior to 0.28, which act as if
<b>prepend</b> was given.
</p>

<h3>Overlay bindings</h3>

<p>
<strong>Note:</strong> This feature is not yet supported by any version of Zero Install, but is proposed for Klik 2.
</p>

<pre>
  &lt;overlay
    src='...' ?
    mount-point='...' ? /&gt;
</pre>

<p>
An overlay binding specifies that the chosen implementation should be made
available at the given location in the filesystem (typically, by using some
kind of per-process union mount).
</p>

<dl>
 <dt>src</dt> <dd>The relative path of the directory in the implementation to publish. The default is '.', to publish everything.</dd>
 <dt>mount-point</dt> <dd>The mount point on which <b>src</b> is to appear in the filesystem. If missing, '/' is assumed.</dd>
</dl>

<p>
For example, if the implementation contains the file <b>usr/games/foo</b> then <b>&lt;overlay /&gt;</b> means that the running process should
be able to access this file using the absolute path <b>/usr/games/foo</b>.
</p>

<h2 id='versions'>Versions</h2>

<p>
A version number string has the following form:
</p>

<pre>
Version := DottedList ("-" Modifier? DottedList?)*
DottedList := (Integer ("." Integer)*)
Modifier := "pre" | "rc" | "post"
</pre>

<p>
Numerically, the modifiers come in the order "-pre" (pre-release), "-rc" (release candidate),
"-" (no modifier name), "-post" (post-release or patch level). Versions are ordered like this:
</p>

<ul>
<li>0.1</li>
<li>1</li>
<li>1.0</li>
<li>1.1</li>
<li>1.2-pre</li>
<li>1.2-pre1</li>
<li>1.2-rc1</li>
<li>1.2</li>
<li>1.2-0</li>
<li>1.2-post</li>
<li>1.2-post1-pre</li>
<li>1.2-post1</li>
<li>1.2.1-pre</li>
<li>1.2.1.4</li>
<li>1.2.2</li>
<li>1.2.10</li>
<li>3</li>
</ul>

<p>
The injector doesn't care about anything other than the sort order (i.e., whether
one version comes before or after another). It is expected that an
implementation can be safely replaced by one with a later version number, but
not necessarily with an earlier one. So, if an application works with version
"1.2.1" of a library then it should also work with version "1.2.2" or "1.3" or
even "5.7", but not "1.2.0". This is a little different to some other systems,
where numbers in different places have different meanings.
</p>

<p>
For example, if the latest version of a library you use is version 5.1, then
you shouldn't add the restriction <b>before='5.2'</b>, because when 5.2 comes
out it should still work with your program. Of course, this might not always work,
and hopefully the problem will be reported while the new library version is marked
as testing (before most users hit the problem). Once you know that 5.2 is a problem,
you can add the <b>before='5.2'</b> restriction to the implementation then.
</p>

<p>
Incompatible changes (where a newer version cannot be used in place of an older
version) to an interface should be handled by creating a new interface URI. Eg:
</p>

<ul>
<li>http://gtk.org/2005/interfaces/GTK-1.2.x (contains 1.2.0, 1.2.1, 1.2.2, ...)</li>
<li>http://gtk.org/2005/interfaces/GTK-2.x (contains 2.0.0, 2.0.1, 2.2.0, 2.4.0, 2.4.1, ...)</li>
</ul>

<p>
Note that version numbers containing dash characters are not supported before version 0.24 of the
injector. To create feeds that still work with older versions, you can use the
<b>version-modifier</b> attribute. E.g., use <b>version='1' version-modifier='-pre'</b> instead
of <b>version='1-pre'</b>. Older versions will silently ignore this attribute.
</p>

<h2 id='stability'>Stability</h2>

<p>
The feed file also gives a stability rating for each implementation. The following
levels are allowed (must be lowercase in the feed files):
</p>

<ul>
<li>stable</li>
<li>testing</li>
<li>developer</li>
<li>buggy</li>
<li>insecure</li>
</ul>

<p>
Stability ratings are expected to change over time. When any new release is
made, its stability should be set to <b>testing</b>. Users who have selected
<b>Help test new versions</b> will then start using it. Other users will
continue with the previous stable release. After a while (days, weeks or
months, depending on the project) with no serious problems found, the
implementation's stability can be changed to <b>stable</b> so that everyone
will use it.
</p>

<p>
If problems are found, it can instead be marked as <b>buggy</b>, or <b>insecure</b>. The injector
won't select either by default, but it is useful to users to see the reason (users may opt to
continue using a buggy version if it seems to work for them, but they should never use an insecure
one). <b>developer</b> is like a more extreme version of <b>testing</b>, where the program is
expected to have bugs.
</p>

<h4>When to use 'buggy'</h4>

<p>
Don't mark old releases as <b>buggy</b> every time you do a new release, just
because a few bugs have been fixed.  People who have selected <b>Network
use: Full</b> will automatically upgrade to the new version anyway, so marking an older
version as buggy only affects people who have explicitly stated that they <b>don't</b>
want to use the latest version, but would prefer to use an older release to
save network use.
</p>


<h2>Metadata</h2>

<p>
All elements can contain extension elements, provided they are not in the Zero
Install namespace used by the elements defined here. The injector does not
currently make use of these elements itself, but other programs may find them
useful. In future, some of these may be used (for example, the GUI may display
the license terms).
</p>

<p>
The use of <a href='http://dublincore.org'>Dublin Core</a> is suggested for the following concepts, which
have the following meanings when found as a direct child of a &lt;group&gt; or &lt;implementation&gt; element:
</p>

<dl>
<dt>dc:creator</dt>
<dd>The primary author of the program.</dd>

<dt>dc:publisher</dt>
<dd>The person who created this implementation. For a binary, this is the person who
compiled it.</dd>

</dl>

<p>
Other Dublin Core terms that may be useful include contributor,
dateCopyrighted, language, rights and rightsHolder.
</p>

<p>
These terms are not required as they are duplicated by the core Zero Install terms: identifier (id),
available (released) and requires (requires).
</p>

<p>
The source element may be used in future to record the source used to build this implementation.
</p>

<h2>Digital signatures</h2>

<p>
When an interface is downloaded from the web, it must contain a digital signature. Two signature formats are
supported:
</p>

<h3>GPG plain signatures</h3>

<p>A plain signature is generated from an unsigned interface using the command
<b>gpg --clearsign</b>. The resulting file is a plain text file but is not valid XML.
This format is supported by all versions of the injector.
</p>

<h3>GPG XML signatures</h3>
<p>An interface can also be signed by appending an XML comment block of the form:</p>
<pre><![CDATA[
<!-- Base64 Signature
iD8DBQBEXM/qrgeCgFmlPMERArNSAKDBuNz5SQMZ8rwJmW2fhNHJwor6KwCgwx7XEfY+6gUC90rJ
b5eCY+I8HNA=

-->]]></pre>

<p>
This block <b>must</b> go at the end of the file, and contains a Base64-encoded version of
the file that would be created by using <b>gpg --detach-sign</b> on the original interface.
The signature block must start on a new line, may not contain anything except valid base64
characters, and nothing may follow the signature block. XML signature blocks are supported
from version 0.18 of the injector and may be generated easily using the
<a href='0publish.html'>0publish</a> command.
They have the advantage that the result is still valid XML and can therefore be processed and
styled using standard tools.
</p>

<p>
Local interfaces are plain XML, although having an XML signature block is no problem as it
will be ignored as a normal comment.
</p>

<h2>Future plans</h2>

<ul>
 <li>The extra meta-data elements need to be better specified.</li>
 <li>In addition to &lt;version&gt;, it should be possible to specifically exclude certain versions or ranges
 of versions so you can say, for example: "2.0 &lt;= version &lt; 3 and version != 2.57".</li>
 <li>As well as before and not-before, we should support after and not-after.</li>
 <li>Additional &lt;recipe&gt; step types should be supported, such as &lt;apply-patch&gt;.</li>
 <li>It should be possible to state that a &lt;requires&gt; is actually optional (or only needed if
 some local library isn't available).</li>
 <li>It should be possible to give a delta (binary patch) against a previous version, to make upgrading
 quicker.</li>
 <li>It should be possible to scope bindings. For example, when a DTP package requires a clipart package, the
 clipart package should not be allowed to affect the DTP package's environment.</li>
</ul>

</html>
