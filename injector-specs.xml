<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<h2>The Injector: Specifications</h2>

<p>
This document is a formal description of the two injector file formats: the interface XML file
format and the manifest file format.
</p>

<p>
Changes to this document (and to the rest of the web-site) are tracked using subversion. To view
the change log:
</p>

<pre>
$ svn log https://svn.sourceforge.net/svnroot/zero-install/trunk/htdocs/injector-specs.xml
</pre>

<h3>Contents</h3>
<toc level='h2'/>

<h2>Interfaces</h2>

<p>
Interface files are introduced in the <a href='injector-packagers.html'>packager's guide</a>.
They have the following syntax (? follows optional items, * means zero-or-more, order of elements
is not important, and extension elements can appear anywhere as long as they use a different
namespace):
</p>

<pre>
&lt;?xml version='1.0'?&gt;
&lt;interface xmlns='http://zero-install.sourceforge.net/2004/injector/interface'
	   min-injector-version='...' ?
	   uri='...' ?
	   main='...' ?&gt;
  &lt;name&gt;...&lt;/name&gt;
  &lt;summary&gt;...&lt;/summary&gt;
  &lt;description&gt;...&lt;/description&gt;
  &lt;homepage&gt;...&lt;/homepage&gt;

  &lt;icon type='...' href='...'/&gt; *
  &lt;feed src='...' arch='...'/&gt; *
  &lt;feed-for interface='...'/&gt; *

  [group] *
  [implementation] *

&lt;/interface&gt;
</pre>

<dl>

<dt>min-injector-version</dt>
<dd>This attribute gives the oldest version of the injector that can read this file. Older versions will
tell the user to upgrade if they are asked to read the file. Versions prior to 0.20 do not perform this check, however.
If the attribute is not present, the file can be read by all versions.
</dd>

<dt>uri</dt>
<dd>This attribute is only needed for remote interfaces (fetched via HTTP). The value must exactly match the expected
URL, to prevent an attacker replacing one correctly-signed interface with another (e.g., returning the interface for the
<b>shred</b> program when the user asked for the <b>backup</b> program).
</dd>

<dt>main</dt>
<dd>
Use of the <b>main</b> attribute here is deprecated; it should appear on the <b>group</b> element instead.
</dd>

<dt>homepage</dt>
<dd>
This element gives the URL of a web-page describing this interface in more detail.
</dd>

</dl>

<h3>Group</h3>

<p>
A group has this syntax:
</p>

<pre>
  &lt;group version='...' ?
       	  released='...' ?
	  main='...' ?
          stability='...' ?
          arch='...' ? &gt;
    [requires] *
    [group] *
    [implementation] *
  &lt;/group&gt;
</pre>

<p>
All attributes of the group are inherited by any child groups and implementations as defaults, but
can be overridden there. All dependencies ("requires") are inherited (sub-groups may add more
dependencies to the list, but cannot remove anything).
</p>

<h3>Implementation</h3>

<p>
An implementation has this syntax (an unspecified argument is inherited from
the closest ancestor &lt;group&gt; which defines it):
</p>

<pre>
  &lt;implementation
	id='...'
  	version='...' ?
	main='...' ?
  	released='...' ?
	stability='...' ?
	arch='...' ? &gt;
    [ retrieval-method ] *
  &lt;/implementation&gt;
</pre>

<dl>
 <dt>id</dt>
 <dd>The digest of the implementation's manifest, in the form <b>alg=value</b>. See below for details about
 manifests. If the interface file is a local file (the interface 'uri' starts with <b>/</b>) then the <b>id</b>
 <i>may</i> instead contain the pathname of a local directory.</dd>

 <dt>version</dt>
 <dd>A list of one or more decimal integers, separated by dots, giving the version number.</dd>

 <dt>main</dt>
 <dd>The relative path of an executable inside the implementation that should be executed by default
 when the interface is run. If an implementation has no <b>main</b> setting, then it cannot be executed
 without specifying one manually (with <b>0launch --main=MAIN</b>). This typically means that the interface
 is for a library.</dd>

 <dt>released</dt>
 <dd>The date this implementation was made available, in the format YYYY-MM-DD. For developer snapshots (e.g., a
 CVS checkout) this is typically set to <b>Snapshot</b>.</dd>

 <dt>stability</dt>
 <dd>The default stability rating for this implementation. If not present, <b>testing</b> is used.</dd>

 <dt>arch</dt>
 <dd>For platform-specific binaries, the platform for which this implementation was compiled, in the form <b>os-cpu</b>.
 The injector knows that certain platforms are backwards-compatible with others, so binaries with <b>arch="Linux-i486"</b>
 will still be available on <i>Linux-i686</i> machines, for example. Either the <i>os</i> or <i>cpu</i> part may be <b>*</b>,
 which will make it available on any OS or CPU. If missing, the default is <b>*-*</b>.</dd>
</dl>

<p>
For non-local implementations (those where the <b>id</b> doesn't start with
<b>/</b>), the element contains a set of <i>retrieval methods</i>, each of
which gives a different way of getting the implementation (i.e., of getting a
directory structure whose digest matches the one in the <b>id</b>).
</p>

<p>
Unrecognised elements inside an implementation are ignored. Currently, the
injector always chooses the first of the methods it understands, but in future
it may use other strategies (such as choosing the closest mirror, or letting
the user select one manually). It may also use other methods which aren't listed,
such as searching for the implementation on a peer-to-peer network.
</p>

<h3>Retrieval methods</h3>

<p>
A retrieval method is a way of getting an implementation. The simplest retrieval method is the &lt;archive&gt; element:
</p>

<pre id='retrievalmethods'>
    &lt;archive
      href='...'
      size='...'
      extract='...' ? /&gt;
</pre>

<p>
This states that an archive may be downloaded from the address given in the <b>href</b> attribute. The archive must
have the given <b>size</b> or it will be rejected. When unpacked (either the subdirectory named in the <b>extract</b>
attribute, or the whole archive if it is not present), the resulting tree will generate a manifest with the secure hash
value given as the implementation's <b>id</b>.
</p>

<p>
An implementation can also be created by following a &lt;recipe&gt;:
</p>

<pre>
  &lt;recipe&gt;
    &lt;archive ...&gt; +
  &lt;/recipe&gt;
</pre>

<p>
In this case, each child element of the recipe represents a step. To get an implementation by following a recipe,
a new empty directory is created and then all of the steps are performed in sequence. The resulting directory
must have the digest given in the implementation's <b>id</b>. A recipe containing only a single archive is equivalent
to just specifying the archive on its own (except that recipes aren't supported prior to version 0.20 of the injector).
If a recipe contains an unrecognised element then the whole recipe must be ignored.
</p>

<p>
The only type of step supported is an &lt;archive&gt;, which causes the named
archive to be fetched and unpacked over the top of whatever is currently in the temporary directory.
</p>

<p>
Note: A recipe is generally only useful for patching existing archives without having to host the complete result
yourself. Normally, if your program requires files from several different packages then it is better to use the
&lt;requires&gt; element instead. This allows libraries to be shared between different programs, and lets the user
choose the versions and upgrade them individually.
</p>

<h3>Requires</h3>

<p>
A &lt;requires&gt; element means that every implementation within the same group (including nested
sub-groups) requires an implementation of the specified interface when run. The injector will choose a
suitable implementation, downloading one if required.
</p>

<pre>
  &lt;requires
	interface='...' &gt;
    [ contraints ] *
    [ bindings ] *
  &lt;/requires&gt;
</pre>

<p>
The constraint elements (if any) limit the set of acceptable versions. The bindings specify how
the injector should make its choice known (typically, by setting environment variables).
</p>

<h3>Constraints</h3>

<p>
Contraints appear inside &lt;requires&gt; elements. They restrict the set of versions from which the
injector may choose an implementation.
</p>

<pre>
    &lt;version
	not-before='...' ?
	before='...' ? &gt;
</pre>

<dl>
<dt>not-before</dt>
<dd>This is the lowest-numbered version that can be chosen.</dd>

<dt>before</dt>
<dd>This version and all later versions are unsuitable.</dd>
</dl>

<p>For example, <b>&lt;version not-before='2.4' before='2.6'&gt;</b> allows any of these
versions: 2.4, 2.4.0, and 2.4.8. It will not select 2.3.9 or 2.6.
</p>

<p>
Note: to specify the highest <i>suitable</i> version, just add ".0" to the end:
<b>before='2.4.3.0'</b> will allow any version up to <i>and including</i> 2.4.3
to be selected.
</p>

<h3>Bindings</h3>

<pre>
    &lt;environment
	  name='...'
	  insert='...'
	  default='...' ? /&gt; *
</pre>

<p>
The location of the chosen implementation is passed to the program by setting environment variables,
as specified by the &lt;environment&gt; elements (typically, there will be exactly one of these in each
&lt;requires&gt; element). Each environment element gives the name of the variable and the relative path
of the item within the implementation to insert into the variable's value. The absolute path of the
item is prepended to the current value of the variable, separated by a colon character. If the
environment variable is not currently set then the path is prepended to the
value of the default attribute. If no default value is given either then the
environment variable's value is set to the absolute path directly.
</p>

<p>
For example, &lt;environment name='PATH' insert='bin'/&gt; would perform something similar to the
bash shell statement <b>export PATH=/path/to/impl/bin:$PATH</b>.
</p>

<h3>Metadata</h3>

<p>
All elements can contain extension elements, provided they are not in the Zero
Install namespace used by the elements defined here. The injector does not
currently make use of these elements itself, but other programs may find them
useful. In future, some of these may be used (for example, the GUI may display
the license terms).
</p>

<p>
The use of <a href='http://dublincore.org'>Dublin Core</a> is suggested for the following concepts, which
have the following meanings when found as a direct child of a &lt;group&gt; or &lt;implementation&gt; element:
</p>

<dl>
<dt>dc:creator</dt>
<dd>The primary author of the program.</dd>

<dt>dc:publisher</dt>
<dd>The person who created this implementation. For a binary, this is the person who
compiled it.</dd>

<dt>dc:license</dt>
<dd>License terms (a URI for the license is suggested).</dd>

</dl>

<p>
Other Dublin Core terms that may be useful include contributor,
dateCopyrighted, language, rights and rightsHolder.
</p>

<p>
These terms are not required as they are duplicated by the core Zero Install terms: identifier (id),
available (released) and requires (requires).
</p>

<p>
The source element may be used in future to record the source interface used to build this implementation.
</p>

<h3>Future plans</h3>

<ul>
 <li>In addition to &lt;version&gt;, it should be possible to specifically exclude certain versions or ranges
 of versions so you can say, for example: "2.0 &lt;= version &lt; 3 and version != 2.57".</li>
 <li>Additional &lt;recipe&gt; step types should be supported, such as &lt;apply-patch&gt;.</li>
 <li>It should be possible to state that a &lt;requires&gt; is actually optional (on only needed if
 some local library isn't available).</li>
 <li>It should be possible to give a delta (binary patch) against a previous version, to make upgrading
 quicker.</li>
</ul>


<h2>Manifest files</h2>

<p>
Implementations are identified by an algorithm name (e.g., "sha1"), and digest
of their contents calculated using that algorithm. Adding, deleting, renaming
or modifying any file in a tree will change its digest. It should be unfeasibly
difficult to generate a new tree with the same digest as a given tree. Thus, if you
know the digest of the implementation you want, and someone gives you a tree with
that digest, you can trust that it is the implementation you want.
</p>

<p>
The currently supported algorithms are:
</p>

<dl>
<dt>sha1</dt><dd>This is supported by all versions of the injector. Its
manifest format is slightly different to the format used with the other algorithms as it
is older.</dd>
<dt>sha1new</dt><dd>Supported from version 0.20. This is the same hash as <b>sha1</b> but with
the new manifest format.</dd>
<dt>sha256</dt><dd>Supported from version 0.20 and also requires the <b>hashlib</b> Python module
to be installed. This should be the most secure.</dd>
</dl>

<p>
When checking a new tree (e.g., that has just been downloaded from the net and
unpacked), the injector generates a 'manifest' file. The manifest lists every
file, directory and symlink in the tree, and gives the digest of each file's
content. Here is a sample manifest file for a tree containing two files
(<b>README</b> and <b>src/main.c</b>) and using the <b>sha1</b> algorithm:
</p>

<pre>
F 0a4d55a8d778e5022fab701977c5d840bbc486d0 1132502750 11 README
D 1132502769 /src
F 83832457b29a423c8e6daf05c6dbcba17d0514dd 1132502769 17 main.c
</pre>

<p>
If you generate a manifest file for a directory tree and find that it is identical
to the manifest file you want, then you can feel confident that you have the tree you
want. This is convenient, because the manifest file is much smaller than the packaged tree.
</p>

<p>
To save even more space, we can simply compare the <i>digests</i> of the manifest
files, rather than comparing the files themselves. The top-level
directory is renamed to this final digest (so the <b>main.c</b> above would be
stored as <b>.../sha1=b848561cd89be1b806ee00008a503c63eb4ad56e/src/main.c</b>,
for example).
</p>

<p>
After checking, the generated manifest file is stored in a file called
<b>.manifest</b> in the top-level of the tree. This is not strictly necessary, but if the tree
is modified later somehow it can show you exactly which files were changed (rather than just letting
you know that the tree has changed in some unknown way).
</p>

<p>
This description of the manifest file is based on Joachim's 12 Oct 2005 post to
the zero-install-devel list:
</p>

<p>
The manifest file lists, line by line, all nodes in a directory 
identified as "/", without "/" itself.  All relevant numbers are coded 
as decimal numbers without leading zeros (unless 0 is to be coded, which 
is coded as "0"). Times are represented as the number of seconds since 
the epoch. Nodes are of one of their possible types: 'D', 'F', 'X', and 
'S'. Names must not contain newline characters (the tree will be rejected if they
do).
</p>

<h3>Directories</h3>

<p>
'D' nodes correspond to directories, and their line format is:
</p>

<pre>"D", space, [mtime, space,] full path name, newline</pre>

<p>
So, top level directories, for example, would have a "full path name" 
that matches the regular expression <b>^/[^/\n]+$</b>.
</p>

<p>
The modification time is only included when using the original <b>sha1</b>
algorithm, as it was not found to be useful and caused problems with many
archives.
</p>

<h3>Files</h3>

<p>
'F' and 'X' nodes correspond to files and executable files, respectively, and
their line formats are:
</p>

<pre>"F", space, hash, space, mtime, space, size, space, file name, newline
"X", space, hash, space, mtime, space, size, space, file name, newline</pre>

<p>
As opposed to directories, no full path names are given. Hence, file 
names match <b>^[^/\n]+$</b> . The hash is the 40-byte hexadecimal representation of
the SHA-1 sum of the contents of the respective file. Hexadecimal digits a
through f are used (rather than A through F).
</p>

<h3>Symlinks</h3>

<p>
'S' nodes correspond to symbolic links, and their line format is:
</p>

<pre>"S", space, hash, size, space, symlink name, newline</pre>

<p>
The symlink name is given analogously to file names in 'F' and 'X' 
nodes.  The size of a symlink is the number of bytes in its target 
(name).  The hash sum, similarly to that of files, is the SHA-1 sum of 
the target (name) of the respective symlink.
</p>

<h3>Other files types</h3>

<p>
It is an error for a tree to contain other types of object (such as device files).
Such trees are rejected.
</p>

<h3>Ordering</h3>

<p>
These lines appear in the order of a depth-first search. Within a directory,
regular files and symlinks come first (ordered lexicographically by their name, i.e., 
they appear in the order that "LC_ALL=C sort" would produce), and then each subdirectory
(again sorted in the same way).
</p>

<p>
For the original <b>sha1</b> algorithm the sort order is slightly different:
sub-directories, regular files and symlinks are all sorted together rather than
the subdirectories always coming after other types.
</p>

<p>
Implementations have to abide by these rules by the letter because such 
a file is to be generated automatically and this process absolutely must 
generate the same file that the directory tree packager had computed.
</p>

</html>
